<?php

namespace Cbi\MalwareChecker;

class MalwareChecker
{
    /**
     * Check a single hash using the DNS protocol
     * @param  string $hash The hash to check
     * @return (array|bool) An array with the malware data or false if not found
     */
    static public function check(string $hash)
    {
        if (!is_string($hash)) {
            throw new \InvalidArgumentException('First argument must of type string');
        }
        // Get the DNS TXT record
        $dnsResponse = dns_get_record($hash.'.malware.hash.cymru.com', DNS_TXT);
        // If the response is empty return false
        if(count($dnsResponse) == 0) {
            return false;
        }
        // Format the TXT response to get the timestamp and detection percentage
        $hashFields = explode(' ', $dnsResponse[0]['txt']);

        return [
            'hash' => $hash,
            'timestamp' => $hashFields[0],
            'detection_percentage' => $hashFields[1]
        ];
    }

    /**
     * Check multiple hashes using the whois protocol
     * @param  array $hashes The hashes to check
     * @return (array|bool)  An array of N malware data or false if none is found
     */
    static public function checkMany(array $hashes)
    {
        if (!is_array($hashes)) {
            throw new \InvalidArgumentException('First argument must be of type array');
        }
        $whoisResponse = '';
        $responses = [];
        // Open a Socket connection to our WHOIS server
        $fp = fsockopen("hash.cymru.com", 43);
        // Send the data
        fwrite($fp, "begin\r\n" . implode("\r\n",$hashes) . "end\r\n");
        // Listen for data and "append" all the bits of information to
        // our result variable until the data stream is finished
        while (!feof($fp)) {
            $whoisResponse .= fgets($fp);
        }
        // Close the connection
        fclose($fp);
        // Explode the whois response and slice the excess
        $individualHashResponses = array_slice(explode("\n", $whoisResponse), 2, -1);
        $totalHashes = count($individualHashResponses);
        // Iterate the individual responses and add the response object to the return array
        for ($i=0; $i < $totalHashes; $i++) {
            $hashFields = explode(' ', $individualHashResponses[$i]);
            if($hashFields[2] != 'NO_DATA') {
                $responses[] = [
                    'hash' => $hashFields[0],
                    'timestamp' => $hashFields[1],
                    'detection_percentage' => $hashFields[2],
                ];
            }
        }
        // If the responses array is empty return false
        if(count($responses) == 0) {
            return false;
        }

        return $responses;
    }

    /**
     * Generates a md5 hash from a resource binaries
     * @param  (resource|string) $file The file resource or uri to hash
     * @param  string $algo The hashing algorithm to use
     * @return string   The generated hash from the file resource
     */
    static public function makeHash($file, $algo = 'md5') : string
    {
        if ((!is_string($file) || !file_exists($file)) && !is_resource($file)) {
            throw new \InvalidArgumentException('First argument must be the uri of an existing file or a resource');
        }
        if (!is_string($algo)) {
            throw new \InvalidArgumentException('Second argument must be of type string');
        }

        $uri = gettype($file) == 'resource' ? stream_get_meta_data($file)['uri'] : $file;

        return hash_file($algo, $uri);
    }

    /**
     * Generates an array of hashes from a resource binaries
     * @param  (resource|string) $file The file resource or uri to hash
     * @param  array $algos The algorithms used to hash the file
     * @return array   The generated hashes from the file
     */
    static public function makeHashes($file, $algos = ['md5']) : array
    {
        if ((!is_string($file) || !file_exists($file)) && !is_resource($file)) {
            throw new \InvalidArgumentException('First argument must be the uri of an existing file or a resource');
        }
        if (!is_array($algos)) {
            throw new \InvalidArgumentException('Second argument must be of type array');
        }

        $uri = gettype($file) == 'resource' ? stream_get_meta_data($file)['uri'] : $file;

        foreach ($algos as $algo) {
            $contexts[$algo] = hash_init ($algo);
        }

        $fp = fopen($uri, 'r');

        if(!$fp) {
            throw new \InvalidArgumentException('Could not read the provided file');
        }

        while(!feof($fp)) {
            $buffer = fgets($fp);
            foreach ($contexts as $context) {
                hash_update($context, $buffer);
            }
        }

        fclose($fp);

        foreach ($contexts as $context) {
            $results[] = hash_final($context);
        }

        return $results;
    }
}
